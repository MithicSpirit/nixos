commit 0269b780f7aabfa64abfc4c2556d21e638583b48
Author: MithicSpirit <rpc01234@gmail.com>
Date:   Fri Oct 3 22:06:20 2025 -0400

    dispatchers: add forceidle
    
    The forceidle dispatcher resets all ext-idle-notify timers as if the
    user had been idle for the specified number of seconds. If a
    notification has already fired, but would now be set with a nonzero
    delay, then it is reset. Conversely, if a timer has not yet fired, but
    would now be set to a nonpositive delay, then it is immediately fired.
    This process ignores any existing inhibitors, but timers are otherwise
    reset as normal if any new inhibitors are created or destroyed.

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 3120157f..f3c46efc 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1,12 +1,13 @@
 #include "../config/ConfigValue.hpp"
 #include "../devices/IKeyboard.hpp"
 #include "../managers/SeatManager.hpp"
 #include "../protocols/LayerShell.hpp"
 #include "../protocols/ShortcutsInhibit.hpp"
 #include "../protocols/GlobalShortcuts.hpp"
+#include "../protocols/IdleNotify.hpp"
 #include "../protocols/core/DataDevice.hpp"
 #include "../render/decorations/CHyprGroupBarDecoration.hpp"
 #include "KeybindManager.hpp"
 #include "PointerManager.hpp"
 #include "Compositor.hpp"
 #include "TokenManager.hpp"
@@ -139,12 +140,13 @@ CKeybindManager::CKeybindManager() {
     m_dispatchers["movewindoworgroup"]              = moveWindowOrGroup;
     m_dispatchers["setignoregrouplock"]             = setIgnoreGroupLock;
     m_dispatchers["denywindowfromgroup"]            = denyWindowFromGroup;
     m_dispatchers["event"]                          = event;
     m_dispatchers["global"]                         = global;
     m_dispatchers["setprop"]                        = setProp;
+    m_dispatchers["forceidle"]                      = forceIdle;
 
     m_scrollTimer.reset();
 
     m_longPressTimer = makeShared<CEventLoopTimer>(
         std::nullopt,
         [this](SP<CEventLoopTimer> self, void* data) {
@@ -3239,12 +3241,25 @@ SDispatchResult CKeybindManager::setProp(std::string args) {
     for (auto const& m : g_pCompositor->m_monitors)
         g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m->m_id);
 
     return {};
 }
 
+SDispatchResult CKeybindManager::forceIdle(std::string args) {
+    std::optional<float> duration = getPlusMinusKeywordResult(args, 0);
+
+    if (!duration.has_value()) {
+        Debug::log(ERR, "Duration invalid in forceIdle!");
+        return {.success = false, .error = "Duration invalid in forceIdle!"};
+    }
+
+    PROTO::idle->setTimers(duration.value() * 1000.0);
+
+    return {};
+}
+
 SDispatchResult CKeybindManager::sendkeystate(std::string args) {
     // args=<NEW_MODKEYS><NEW_KEY><STATE>[,WINDOW_RULES]
     const auto ARGS = CVarList(args, 4);
     if (ARGS.size() != 4) {
         Debug::log(ERR, "sendkeystate: invalid args");
         return {.success = false, .error = "sendkeystate: invalid args"};
diff --git a/src/managers/KeybindManager.hpp b/src/managers/KeybindManager.hpp
index 2272aa8f..8f5516ed 100644
--- a/src/managers/KeybindManager.hpp
+++ b/src/managers/KeybindManager.hpp
@@ -226,12 +226,13 @@ class CKeybindManager {
     static SDispatchResult moveWindowOrGroup(std::string);
     static SDispatchResult setIgnoreGroupLock(std::string);
     static SDispatchResult denyWindowFromGroup(std::string);
     static SDispatchResult global(std::string);
     static SDispatchResult event(std::string);
     static SDispatchResult setProp(std::string);
+    static SDispatchResult forceIdle(std::string);
 
     friend class CCompositor;
     friend class CInputManager;
     friend class CConfigManager;
     friend class CWorkspace;
     friend class CPointerManager;
diff --git a/src/protocols/IdleNotify.cpp b/src/protocols/IdleNotify.cpp
index 0ebe24e3..4122bf24 100644
--- a/src/protocols/IdleNotify.cpp
+++ b/src/protocols/IdleNotify.cpp
@@ -18,13 +18,13 @@ CExtIdleNotification::CExtIdleNotification(SP<CExtIdleNotificationV1> resource_,
     m_resource->setDestroy([this](CExtIdleNotificationV1* r) { PROTO::idle->destroyNotification(this); });
     m_resource->setOnDestroy([this](CExtIdleNotificationV1* r) { PROTO::idle->destroyNotification(this); });
 
     m_timer = makeShared<CEventLoopTimer>(std::nullopt, onTimer, this);
     g_pEventLoopManager->addTimer(m_timer);
 
-    updateTimer();
+    update();
 
     LOGM(LOG, "Registered idle-notification for {}ms", timeoutMs_);
 }
 
 CExtIdleNotification::~CExtIdleNotification() {
     g_pEventLoopManager->removeTimer(m_timer);
@@ -32,30 +32,45 @@ CExtIdleNotification::~CExtIdleNotification() {
 }
 
 bool CExtIdleNotification::good() {
     return m_resource->resource();
 }
 
-void CExtIdleNotification::updateTimer() {
-    if (PROTO::idle->isInhibited && m_obeyInhibitors)
-        m_timer->updateTimeout(std::nullopt);
-    else
-        m_timer->updateTimeout(std::chrono::milliseconds(m_timeoutMs));
+void CExtIdleNotification::update(uint32_t elapsedMs) {
+    m_timer->updateTimeout(std::nullopt);
+
+    if (elapsedMs == 0 && PROTO::idle->isInhibited && m_obeyInhibitors) {
+        reset();
+        return;
+    }
+
+    if (m_timeoutMs > elapsedMs) {
+        reset();
+        m_timer->updateTimeout(std::chrono::milliseconds(m_timeoutMs - elapsedMs));
+    } else
+        onTimerFired();
+}
+
+void CExtIdleNotification::update() {
+    update(0);
 }
 
 void CExtIdleNotification::onTimerFired() {
+    if (m_idled)
+        return;
+
     m_resource->sendIdled();
     m_idled = true;
 }
 
-void CExtIdleNotification::onActivity() {
-    if (m_idled)
-        m_resource->sendResumed();
+void CExtIdleNotification::reset() {
+    if (!m_idled)
+        return;
 
+    m_resource->sendResumed();
     m_idled = false;
-    updateTimer();
 }
 
 bool CExtIdleNotification::inhibitorsAreObeyed() const {
     return m_obeyInhibitors;
 }
 
@@ -93,17 +108,23 @@ void CIdleNotifyProtocol::onGetNotification(CExtIdleNotifierV1* pMgr, uint32_t i
         return;
     }
 }
 
 void CIdleNotifyProtocol::onActivity() {
     for (auto const& n : m_notifications) {
-        n->onActivity();
+        n->update();
     }
 }
 
 void CIdleNotifyProtocol::setInhibit(bool inhibited) {
     isInhibited = inhibited;
     for (auto const& n : m_notifications) {
         if (n->inhibitorsAreObeyed())
-            n->onActivity();
+            n->update();
+    }
+}
+
+void CIdleNotifyProtocol::setTimers(uint32_t elapsedMs) {
+    for (auto const& n : m_notifications) {
+        n->update(elapsedMs);
     }
 }
diff --git a/src/protocols/IdleNotify.hpp b/src/protocols/IdleNotify.hpp
index 02b59e65..0e0433a4 100644
--- a/src/protocols/IdleNotify.hpp
+++ b/src/protocols/IdleNotify.hpp
@@ -11,35 +11,39 @@ class CExtIdleNotification {
   public:
     CExtIdleNotification(SP<CExtIdleNotificationV1> resource_, uint32_t timeoutMs, bool obeyInhibitors);
     ~CExtIdleNotification();
 
     bool good();
     void onTimerFired();
-    void onActivity();
 
     bool inhibitorsAreObeyed() const;
 
   private:
     SP<CExtIdleNotificationV1> m_resource;
     uint32_t                   m_timeoutMs = 0;
     SP<CEventLoopTimer>        m_timer;
 
     bool                       m_idled          = false;
     bool                       m_obeyInhibitors = false;
 
-    void                       updateTimer();
+    void                       reset();
+    void                       update();
+    void                       update(uint32_t elapsedMs);
+
+    friend class CIdleNotifyProtocol;
 };
 
 class CIdleNotifyProtocol : public IWaylandProtocol {
   public:
     CIdleNotifyProtocol(const wl_interface* iface, const int& ver, const std::string& name);
 
     virtual void bindManager(wl_client* client, void* data, uint32_t ver, uint32_t id);
 
     void         onActivity();
     void         setInhibit(bool inhibited);
+    void         setTimers(uint32_t elapsedMs);
 
   private:
     void onManagerResourceDestroy(wl_resource* res);
     void destroyNotification(CExtIdleNotification* notif);
     void onGetNotification(CExtIdleNotifierV1* pMgr, uint32_t id, uint32_t timeout, wl_resource* seat, bool obeyInhibitors);
 
